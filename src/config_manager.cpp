#include "lm/config_manager.hpp"
#include <algorithm>
#include <cctype>

namespace lm {

ConfigManager::ConfigManager(const std::string& config_path) 
    : config_path_(config_path) {
    // Try to load existing config, create default if not found
    if (!load_config()) {
        std::cout << "Config file not found. Creating default configuration..." << std::endl;
        create_default_config();
        save_config();
    }
}

bool ConfigManager::load_config() {
    std::ifstream file(config_path_);
    if (!file.is_open()) {
        std::cout << "Configuration file '" << config_path_ << "' not found." << std::endl;
        return false;
    }
    
    std::cout << "Loading configuration from: " << config_path_ << std::endl;
    
    std::string line;
    int line_number = 0;
    int loaded_params = 0;
    
    while (std::getline(file, line)) {
        line_number++;
        trim(line);
        
        // Skip empty lines and comments
        if (line.empty() || line[0] == '#' || line[0] == ';') {
            continue;
        }
        
        std::string key, value;
        if (!parse_line(line, key, value)) {
            std::cerr << "Warning: Invalid config line " << line_number << ": " << line << std::endl;
            continue;
        }
        
        // Parse known parameters
        if (key == "stability_factor") {
            config_.stability_factor = parse_double(value);
            loaded_params++;
        }
        else if (key == "aggressive_normalization") {
            config_.aggressive_normalization = parse_bool(value);
            loaded_params++;
        }
        else if (key == "min_sequence_length") {
            config_.min_sequence_length = parse_size_t(value);
            loaded_params++;
        }
        else if (key == "max_sequence_length") {
            config_.max_sequence_length = parse_size_t(value);
            loaded_params++;
        }
        else if (key == "preserve_paragraphs") {
            config_.preserve_paragraphs = parse_bool(value);
            loaded_params++;
        }
        else if (key == "preserve_punctuation") {
            config_.preserve_punctuation = parse_bool(value);
            loaded_params++;
        }
        else if (key == "handle_contractions") {
            config_.handle_contractions = parse_bool(value);
            loaded_params++;
        }
        else if (key == "vocab_size") {
            config_.vocab_size = parse_size_t(value);
            loaded_params++;
        }
        else if (key == "min_frequency") {
            config_.min_frequency = parse_size_t(value);
            loaded_params++;
        }
        else if (key == "max_iterations") {
            config_.max_iterations = parse_int(value);
            loaded_params++;
        }
        else if (key == "debug_logging") {
            config_.debug_logging = parse_bool(value);
            loaded_params++;
        }
        else if (key == "verbose_output") {
            config_.verbose_output = parse_bool(value);
            loaded_params++;
        }
        else {
            std::cerr << "Warning: Unknown config parameter '" << key << "' on line " << line_number << std::endl;
        }
    }
    
    file.close();
    
    std::cout << "Loaded " << loaded_params << " configuration parameters." << std::endl;
    
    if (!validate_config()) {
        std::cerr << "Warning: Configuration validation failed. Some parameters may be reset to defaults." << std::endl;
        // Reset invalid parameters to defaults
        reset_to_defaults();
    }
    
    if (config_.verbose_output) {
        print_config();
    }
    
    return true;
}

bool ConfigManager::save_config() const {
    std::ofstream file(config_path_);
    if (!file.is_open()) {
        std::cerr << "Error: Could not create config file: " << config_path_ << std::endl;
        return false;
    }
    
    // Write header
    file << "# BPE Tokenizer Training Configuration" << std::endl;
    file << "# This file is automatically generated" << std::endl;
    file << "# Modify values as needed for your training requirements" << std::endl;
    file << std::endl;
    
    // Stability and training parameters
    file << "# Stability and training parameters (0.1 = very stable, 1.0 = aggressive)" << std::endl;
    file << "stability_factor = " << std::fixed << std::setprecision(2) << config_.stability_factor << std::endl;
    file << "aggressive_normalization = " << bool_to_str(config_.aggressive_normalization) << std::endl;
    file << "min_sequence_length = " << config_.min_sequence_length << std::endl;
    file << "max_sequence_length = " << config_.max_sequence_length << std::endl;
    file << std::endl;
    
    // Literary text handling
    file << "# Literary text handling" << std::endl;
    file << "preserve_paragraphs = " << bool_to_str(config_.preserve_paragraphs) << std::endl;
    file << "preserve_punctuation = " << bool_to_str(config_.preserve_punctuation) << std::endl;
    file << "handle_contractions = " << bool_to_str(config_.handle_contractions) << std::endl;
    file << std::endl;
    
    // BPE training parameters
    file << "# BPE training parameters" << std::endl;
    file << "vocab_size = " << config_.vocab_size << std::endl;
    file << "min_frequency = " << config_.min_frequency << std::endl;
    file << "max_iterations = " << config_.max_iterations << std::endl;
    file << std::endl;
    
    // Debug and logging
    file << "# Debug and logging" << std::endl;
    file << "debug_logging = " << bool_to_str(config_.debug_logging) << std::endl;
    file << "verbose_output = " << bool_to_str(config_.verbose_output) << std::endl;
    
    file.close();
    
    std::cout << "Configuration saved to: " << config_path_ << std::endl;
    return true;
}

void ConfigManager::create_default_config() {
    std::cout << "Creating default configuration optimized for literary text..." << std::endl;
    reset_to_defaults();
}

bool ConfigManager::validate_config() const {
    bool valid = true;
    
    if (config_.stability_factor < 0.1 || config_.stability_factor > 1.0) {
        std::cerr << "Error: stability_factor must be between 0.1 and 1.0" << std::endl;
        valid = false;
    }
    
    if (config_.min_sequence_length < 1) {
        std::cerr << "Error: min_sequence_length must be at least 1" << std::endl;
        valid = false;
    }
    
    if (config_.max_sequence_length < config_.min_sequence_length) {
        std::cerr << "Error: max_sequence_length must be greater than min_sequence_length" << std::endl;
        valid = false;
    }
    
    if (config_.max_sequence_length > 100000) {
        std::cerr << "Warning: max_sequence_length is very large, may cause memory issues" << std::endl;
    }
    
    if (config_.vocab_size < 100) {
        std::cerr << "Error: vocab_size must be at least 100" << std::endl;
        valid = false;
    }
    
    if (config_.vocab_size > 1000000) {
        std::cerr << "Warning: vocab_size is very large, training may be slow" << std::endl;
    }
    
    if (config_.min_frequency < 1) {
        std::cerr << "Error: min_frequency must be at least 1" << std::endl;
        valid = false;
    }
    
    if (config_.max_iterations < 100) {
        std::cerr << "Error: max_iterations must be at least 100" << std::endl;
        valid = false;
    }
    
    return valid;
}

void ConfigManager::reset_to_defaults() {
    config_ = TrainingConfig(); // Reset to default values
}

// Helper methods
bool ConfigManager::parse_line(const std::string& line, std::string& key, std::string& value) {
    size_t equals_pos = line.find('=');
    if (equals_pos == std::string::npos) {
        return false;
    }
    
    key = line.substr(0, equals_pos);
    value = line.substr(equals_pos + 1);
    
    trim(key);
    trim(value);
    
    return !key.empty() && !value.empty();
}

void ConfigManager::trim(std::string& str) {
    // Remove leading whitespace
    str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](unsigned char ch) {
        return !std::isspace(ch);
    }));
    
    // Remove trailing whitespace
    str.erase(std::find_if(str.rbegin(), str.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
    }).base(), str.end());
}

bool ConfigManager::parse_bool(const std::string& str) const {
    std::string lower_str = str;
    std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(), ::tolower);
    
    if (lower_str == "true" || lower_str == "1" || lower_str == "yes" || lower_str == "on") {
        return true;
    }
    if (lower_str == "false" || lower_str == "0" || lower_str == "no" || lower_str == "off") {
        return false;
    }
    
    std::cerr << "Warning: Invalid boolean value '" << str << "', using default" << std::endl;
    return false;
}

double ConfigManager::parse_double(const std::string& str) const {
    try {
        return std::stod(str);
    } catch (const std::exception& e) {
        std::cerr << "Warning: Invalid double value '" << str << "', using default" << std::endl;
        return 0.0;
    }
}

int ConfigManager::parse_int(const std::string& str) const {
    try {
        return std::stoi(str);
    } catch (const std::exception& e) {
        std::cerr << "Warning: Invalid integer value '" << str << "', using default" << std::endl;
        return 0;
    }
}

size_t ConfigManager::parse_size_t(const std::string& str) const {
    try {
        return std::stoul(str);
    } catch (const std::exception& e) {
        std::cerr << "Warning: Invalid size_t value '" << str << "', using default" << std::endl;
        return 0;
    }
}

} // namespace lm
